
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Parsing bit streams &mdash; Tips and tricks v0v1 documentation</title>
    <link rel="stylesheet" href="_static/xdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0v1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="Tips and tricks v0v1 documentation" href="index.html" />
    <link rel="next" title="Pseudo Random Numbers" href="pseudo-random-numbers.html" />
    <link rel="prev" title="Hash tables" href="hash-tables.html" /> 

<script>
function setheight() {
h1 = document.getElementById('d1').style.height;
h2 = document.getElementById('d2').style.height;

if (parseInt(h1) > parseInt(h2)) {
document.getElementById('d2').style.height=h1 + "px";
}
else {
document.getElementById('d1').style.height=h2 + "px";
}

}
</script>
</head>

<body onload="setheight();">

  

    <div class="document" id='d1'>
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
<div style="float: right">
<a href="hash-tables.html"
                        title="previous chapter"> &lt&lt </a>
<a href="pseudo-random-numbers.html"
                        title="next chapter"> &gt&gt </a></p>
</div>

            
  <div class="section" id="parsing-bit-streams">
<h1>Parsing bit streams<a class="headerlink" href="#parsing-bit-streams" title="Permalink to this headline">¶</a></h1>
<p>Many I/O interfaces require a bit-stream to be parsed. A simple parser
maintains a state, and on every input a state transition is made:</p>
<div class="highlight-none"><div class="highlight"><pre>while(...) {
  p :&gt; x;
  state = newstate[state][x];
}
</pre></div>
</div>
<p>This method works fine, under two assumptions:</p>
<ol class="arabic simple">
<li>There is enough time to perform the table lookup.</li>
<li>There is enough memory to store the table.</li>
</ol>
<p>The latter can be a problem if the table is not very dense. For example, if
<tt class="docutils literal"><span class="pre">p</span></tt> is an 8-bit port (or an 8-bit buffered 1-bit port), it will
result in values between 0 and 255, but only one or two of these values may
be legal in any one state. In this case, a large part of the table will be
empty, or filled with <a href="#id1"><span class="problematic" id="id2">``</span></a>ERROR&#8217;&#8217; states.</p>
<p>There are two other methods to parse a bit stream that avoid the above two
problems; a faster method that encodes the state in the code space, and a
memory efficient method that uses a hash table.</p>
<div class="section" id="encoding-the-state-in-code-space">
<h2>Encoding the state in code space<a class="headerlink" href="#encoding-the-state-in-code-space" title="Permalink to this headline">¶</a></h2>
<p>In order to encode the state machine in the code space, a {em label} is used to denote each state;
an input to obtain data, and a conditional (or computed) branch to perform
a state change. For example, the following code has four states, encoding
the last two bits of data that have been input on a one bit port:</p>
<div class="highlight-none"><div class="highlight"><pre>S00:
   in    r1, res[r0]
   bf    r1, S00
S01:
   in    r1, res[r0]
   bf    r1, S10
S11:
   in    r1, res[r0]
   bt    r1, S11
S10:
   in    r1, res[r0]
   bt    r1, S01
   bu    S00
</pre></div>
</div>
<p>The longest trail of instructions between two subsequent inputs is three,
hence this system can parse one bit every three thread cycles. Extra
instructions can be added to the code to do something useful on
state transactions.</p>
<p>More bits can be parsed at any one time by using a buffered port, for example a
4-bit buffered port that will result in a 4-bit value, where a <tt class="docutils literal"><span class="pre">bru</span></tt>
instruction can be used to jump based on that value, and <tt class="docutils literal"><span class="pre">bl</span></tt> instructions to
jump to a new state (note that a <tt class="docutils literal"><span class="pre">bl</span></tt> instruction can jump up to
1024 instructions either way). When values are input from a serialising
port, the least significant bit is the oldest bit, and the most significant
bit input is the most recent bit. Hence, if on a 4-bit port the value
<tt class="docutils literal"><span class="pre">0010</span></tt> (2) appears, then that means that the port clocked in a
&#8216;0&#8217;, a &#8216;1&#8217;, a &#8216;0&#8217;, and a &#8216;0&#8217;. In the state machine we reflect this by
jumping to a state <tt class="docutils literal"><span class="pre">S0100</span></tt>:</p>
<div class="highlight-none"><div class="highlight"><pre>S:
   IN       r1, r0
   BRU      r1
   BLRF_u10 S0000
   BLRF_u10 S1000 // Input was &#39;1&#39; followed by three times a &#39;0&#39;
   BLRF_u10 S0100 // Input was &#39;0&#39; followed by a &#39;1&#39; and two &#39;0&#39;
   BLRF_u10 S1100 // ...
   ...
   BLRF_u10 S1111

...

S0100:
   IN       r1, r0
   BRU      r1
   BLRF_u10 S01000000
   BLRF_u10 S01000001
   BLRF_u10 S01000010
   BLRF_u10 S01000011
   ...
   BLRF_u10 S01001111
</pre></div>
</div>
<p>Obviously, extra instructions need to be added to perform operations, and
the state space needs to be pruned to avoid unreachable states. For
example, one may always expect at least three equal bits in a row, eg
patterns such as <a href="#id3"><span class="problematic" id="id4">``</span></a>00100&#8217;&#8217; are impossible. In this case many of the above
states are illegal and can be covered by a single ERROR state.</p>
<p>Note that the BRU instruction jumps over $n$ 16-bit instructions, and that all
entries in the jumptable should hence be short instructions. Hence they
have been specified as being lstinline+BLRF_u10+ instructions.</p>
</div>
<div class="section" id="encoding-the-state-transitions-in-a-hash-table">
<h2>Encoding the state transitions in a hash table<a class="headerlink" href="#encoding-the-state-transitions-in-a-hash-table" title="Permalink to this headline">¶</a></h2>
<p>The above strategies work fine when small numbers of bits are input at a
time. When large numbers of bits are input that contain only few legal
sequences, these sequences can be stored in a hash table, and hash function
used to perform the state transitions. For example, if a low frequency
signal is sampled at a high rate, and the data is buffered into a 32-bit
value, the only legal values expected are:</p>
<div class="highlight-none"><div class="highlight"><pre>00000000000000000000000000000000
00000000000000000000000000000001
00000000000000000000000000000011
00000000000000000000000000000111
...
01111111111111111111111111111111
11111111111111111111111111111111
11111111111111111111111111111110
11111111111111111111111111111100
...
10000000000000000000000000000000
</pre></div>
</div>
<p>A hashtable can be built containing those values (see
Section~ref{section:hash}), this hashtable can contain state values and
encode operations to be performed on state transitions:</p>
<div class="highlight-none"><div class="highlight"><pre>while(1) {
  p :&gt; x;
  hash = hashValue(x);
  state = newState(state, hash)
  // Operations based on state.
}
</pre></div>
</div>
<p>Given that only 64 legal values need to be encoded, a polynomial with 6 or
7 bits will probably do the trick, and all polynomials of 6 and 7 bits can
be searched ones in order to create an optimal hash.</p>
</div>
<div class="section" id="parsing-an-aligned-bit-stream-by-sampling">
<h2>Parsing an aligned bit stream by sampling<a class="headerlink" href="#parsing-an-aligned-bit-stream-by-sampling" title="Permalink to this headline">¶</a></h2>
<p>If a bit stream has a known frequency relative to the XCore (give or take a
few percent), then the stream can be parsed by oversampling the data on a
port by a factor $n$, waiting for the start-bit, parse the <em>n/2</em> th bit, and
then every $n$th bit until the end of the packet.</p>
<p>For example, suppose that we expect a stream of bits at 12.288 Mhz, then we
can oversample at 100 Mhz (oversampled by a factor 8.13). Wait for the
start bit, and then sample bits 4, 12, 20, 28, 37, 45, 53, 61, etc.</p>
<p>In order to sample those bits, the port is set to buffer 32 bits, and on
the first word the bits are masked out using a mask <tt class="docutils literal"><span class="pre">0x08080808</span></tt>.
In the second word, the mask used is <tt class="docutils literal"><span class="pre">0x04040404</span></tt>, etc. Each mask
leaves four recovered bits in four places in the word, and these can be
recovered by applying a CRC with a polynomial of +0xf+, which
implements a perfect hash onto the last four bits, and a lookup table with
16 elements to recover the 16 possible sampled values:</p>
<div class="highlight-none"><div class="highlight"><pre>p when pinsneq(0) :&gt; int _;        // align first bit
p :&gt; word;                         // read first word
fourBits = (word &lt;&lt; 4) &amp; 0x80808080;
crc32(fourBits, 0xf, 0xf);         // compress bits
data = lookupCrcF[fourBits];       // recover data
p :&gt; word;                         // read second word
fourBits = (word &lt;&lt; 5) &amp; 0x80808080;
crc32(fourBits, 0xf, 0xf);
data = data &lt;&lt; 4 | lookupCrcF[fourBits];
</pre></div>
</div>
<p>Note that rather than using different masks, the same mask is reused on
each inputted word, and the input data is shifted. This means that the four
sampled bits are always in the same location (bits 7, 15, 23, and 31), and
the same lookup table can be used on both the first and the second word.
The array to lookup the CRC values should be initialised with the values
<tt class="docutils literal"><span class="pre">{8,9,12,13,7,6,3,2,10,11,14,15,5,4,1,0}</span></tt>; the array values
depend on the mask, the polynomial, and the initial value chosen.</p>
<p>Note that the above code requires around five instructions for each word;
leaving plenty of time for other operations, such as NRZ decoding, or
removing stuff bits.</p>
</div>
<div class="section" id="finding-the-alignment-of-a-bit-stream">
<h2>Finding the alignment of a bit stream<a class="headerlink" href="#finding-the-alignment-of-a-bit-stream" title="Permalink to this headline">¶</a></h2>
<p>If instead of re-aligning a bit stream, it is just important to establish
the alignment, then the {em count leading zeroes} instruction comes in
useful. A combination of an input followed by a <tt class="docutils literal"><span class="pre">clz()</span></tt> will, in a total of two
thread cycles, return the bit number of the first &#8216;1&#8217; bit that was
received. If the first one is required, the input data should be
complemented, using <tt class="docutils literal"><span class="pre">clz(~x)</span></tt>. The bit reverse instruction can be
used to count the number of trailing zeroes: <tt class="docutils literal"><span class="pre">clz(bitrev(x))</span></tt>.</p>
</div>
</div>



          </div>
        </div>
      </div>
      <div class="sphinxsidebar" id='d2'>
        <div class="sphinxsidebarwrapper">
<h3><a href="index.html">Table Of Contents</a></h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="clearing-registers.html">Clearing two registers simultaneously</a></li>
<li class="toctree-l1"><a class="reference internal" href="div-mod.html">Division and modulo</a></li>
<li class="toctree-l1"><a class="reference internal" href="extra-registers.html">Using extra registers</a></li>
<li class="toctree-l1"><a class="reference internal" href="generating-bit-streams.html">Generating bit streams</a></li>
<li class="toctree-l1"><a class="reference internal" href="hash-tables.html">Hash tables</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="">Parsing bit streams</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#encoding-the-state-in-code-space">Encoding the state in code space</a></li>
<li class="toctree-l2"><a class="reference internal" href="#encoding-the-state-transitions-in-a-hash-table">Encoding the state transitions in a hash table</a></li>
<li class="toctree-l2"><a class="reference internal" href="#parsing-an-aligned-bit-stream-by-sampling">Parsing an aligned bit stream by sampling</a></li>
<li class="toctree-l2"><a class="reference internal" href="#finding-the-alignment-of-a-bit-stream">Finding the alignment of a bit stream</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="pseudo-random-numbers.html">Pseudo Random Numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="realign-streams.html">Realigning a data stream</a></li>
<li class="toctree-l1"><a class="reference internal" href="short-fifo.html">Building short FIFOs</a></li>
<li class="toctree-l1"><a class="reference internal" href="sqrt-log.html">Computing a logarithm or sqrt</a></li>
<li class="toctree-l1"><a class="reference internal" href="threading-speedup.html">Using multiple threads for super linear speedup</a></li>
</ul>

<div id="searchbox" style="display: none">
  <h3>Search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>



    <div class="footer">
    </div>
  </body>
</html>



